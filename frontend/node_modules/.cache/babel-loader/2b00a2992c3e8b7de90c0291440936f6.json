{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\Ambuj\\\\Desktop\\\\Coding\\\\web-projects\\\\tourela\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"C:\\\\Users\\\\Ambuj\\\\Desktop\\\\Coding\\\\web-projects\\\\tourela\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Ambuj\\\\Desktop\\\\Coding\\\\web-projects\\\\tourela\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Ambuj\\\\Desktop\\\\Coding\\\\web-projects\\\\tourela\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Ambuj\\\\Desktop\\\\Coding\\\\web-projects\\\\tourela\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Ambuj\\\\Desktop\\\\Coding\\\\web-projects\\\\tourela\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { getTranslateOffset, transformItem, setItemTransition, binarySearch, schd, isTouchEvent, checkIfInteractive } from './utils.js';\nvar AUTOSCROLL_ACTIVE_OFFSET = 200;\nvar AUTOSCROLL_SPEED_RATIO = 10;\n\nvar List = /*#__PURE__*/function (_React$Component) {\n  _inherits(List, _React$Component);\n\n  function List(props) {\n    var _this;\n\n    _classCallCheck(this, List);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(List).call(this, props));\n    _this.listRef = React.createRef();\n    _this.ghostRef = React.createRef();\n    _this.topOffsets = [];\n    _this.itemTranslateOffsets = [];\n    _this.initialYOffset = 0;\n    _this.lastScroll = 0;\n    _this.lastYOffset = 0;\n    _this.lastListYOffset = 0;\n    _this.needle = -1;\n    _this.afterIndex = -2;\n    _this.state = {\n      itemDragged: -1,\n      itemDraggedOutOfBounds: -1,\n      selectedItem: -1,\n      initialX: 0,\n      initialY: 0,\n      targetX: 0,\n      targetY: 0,\n      targetHeight: 0,\n      targetWidth: 0,\n      liveText: '',\n      scrollingSpeed: 0,\n      scrollWindow: false\n    };\n\n    _this.doScrolling = function () {\n      var _this$state = _this.state,\n          scrollingSpeed = _this$state.scrollingSpeed,\n          scrollWindow = _this$state.scrollWindow;\n      var listEl = _this.listRef.current;\n      window.requestAnimationFrame(function () {\n        if (scrollWindow) {\n          window.scrollTo(window.pageXOffset, window.pageYOffset + scrollingSpeed * 1.5);\n        } else {\n          listEl.scrollTop += scrollingSpeed;\n        }\n\n        if (scrollingSpeed !== 0) {\n          _this.doScrolling();\n        }\n      });\n    };\n\n    _this.getChildren = function () {\n      if (_this.listRef && _this.listRef.current) {\n        return Array.from(_this.listRef.current.children);\n      }\n\n      console.warn('No items found in the List container. Did you forget to pass & spread the `props` param in renderList?');\n      return [];\n    };\n\n    _this.calculateOffsets = function () {\n      _this.topOffsets = _this.getChildren().map(function (item) {\n        return item.getBoundingClientRect().top;\n      });\n      _this.itemTranslateOffsets = _this.getChildren().map(function (item) {\n        return getTranslateOffset(item);\n      });\n    };\n\n    _this.getTargetIndex = function (e) {\n      return _this.getChildren().findIndex(function (child) {\n        return child === e.target || child.contains(e.target);\n      });\n    };\n\n    _this.onMouseOrTouchStart = function (e) {\n      if (_this.dropTimeout && _this.state.itemDragged > -1) {\n        window.clearTimeout(_this.dropTimeout);\n\n        _this.finishDrop();\n      }\n\n      var isTouch = isTouchEvent(e);\n      if (!isTouch && e.button !== 0) return;\n\n      var index = _this.getTargetIndex(e);\n\n      if (index === -1 || // @ts-ignore\n      _this.props.values[index] && _this.props.values[index].disabled) {\n        if (_this.state.selectedItem !== -1) {\n          _this.setState({\n            selectedItem: -1\n          });\n\n          _this.finishDrop();\n        }\n\n        return;\n      }\n\n      var listItemTouched = _this.getChildren()[index];\n\n      var handle = listItemTouched.querySelector('[data-movable-handle]');\n\n      if (handle && !handle.contains(e.target)) {\n        return;\n      }\n\n      if (checkIfInteractive(e.target, listItemTouched)) {\n        return;\n      }\n\n      e.preventDefault();\n      _this.props.beforeDrag && _this.props.beforeDrag({\n        elements: _this.getChildren(),\n        index: index\n      });\n\n      if (isTouch) {\n        var opts = {\n          passive: false\n        };\n        listItemTouched.style.touchAction = 'none';\n        document.addEventListener('touchend', _this.schdOnEnd, opts);\n        document.addEventListener('touchmove', _this.schdOnTouchMove, opts);\n        document.addEventListener('touchcancel', _this.schdOnEnd, opts);\n      } else {\n        document.addEventListener('mousemove', _this.schdOnMouseMove);\n        document.addEventListener('mouseup', _this.schdOnEnd);\n\n        var listItemDragged = _this.getChildren()[_this.state.itemDragged];\n\n        if (listItemDragged && listItemDragged.style) {\n          listItemDragged.style.touchAction = '';\n        }\n      }\n\n      _this.onStart(listItemTouched, isTouch ? e.touches[0].clientX : e.clientX, isTouch ? e.touches[0].clientY : e.clientY, index);\n    };\n\n    _this.getYOffset = function () {\n      var listScroll = _this.listRef.current ? _this.listRef.current.scrollTop : 0;\n      return window.pageYOffset + listScroll;\n    };\n\n    _this.onStart = function (target, clientX, clientY, index) {\n      if (_this.state.selectedItem > -1) {\n        _this.setState({\n          selectedItem: -1\n        });\n\n        _this.needle = -1;\n      }\n\n      var targetRect = target.getBoundingClientRect();\n      var targetStyles = window.getComputedStyle(target);\n\n      _this.calculateOffsets();\n\n      _this.initialYOffset = _this.getYOffset();\n      _this.lastYOffset = window.pageYOffset;\n      _this.lastListYOffset = _this.listRef.current.scrollTop;\n\n      _this.setState({\n        itemDragged: index,\n        targetX: targetRect.left - parseInt(targetStyles['margin-left'], 10),\n        targetY: targetRect.top - parseInt(targetStyles['margin-top'], 10),\n        targetHeight: targetRect.height,\n        targetWidth: targetRect.width,\n        initialX: clientX,\n        initialY: clientY\n      });\n    };\n\n    _this.onMouseMove = function (e) {\n      e.cancelable && e.preventDefault();\n\n      _this.onMove(e.clientX, e.clientY);\n    };\n\n    _this.onTouchMove = function (e) {\n      e.cancelable && e.preventDefault();\n\n      _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n    };\n\n    _this.onWheel = function (e) {\n      if (_this.state.itemDragged < 0) return;\n      _this.lastScroll = _this.listRef.current.scrollTop += e.deltaY;\n\n      _this.moveOtherItems();\n    };\n\n    _this.onMove = function (clientX, clientY) {\n      if (_this.state.itemDragged === -1) return null;\n      transformItem(_this.ghostRef.current, clientY - _this.state.initialY, _this.props.lockVertically ? 0 : clientX - _this.state.initialX);\n\n      _this.autoScrolling(clientY);\n\n      _this.moveOtherItems();\n    };\n\n    _this.moveOtherItems = function () {\n      var targetRect = _this.ghostRef.current.getBoundingClientRect();\n\n      var itemVerticalCenter = targetRect.top + targetRect.height / 2;\n      var offset = getTranslateOffset(_this.getChildren()[_this.state.itemDragged]);\n\n      var currentYOffset = _this.getYOffset(); // adjust offsets if scrolling happens during the item movement\n\n\n      if (_this.initialYOffset !== currentYOffset) {\n        _this.topOffsets = _this.topOffsets.map(function (offset) {\n          return offset - (currentYOffset - _this.initialYOffset);\n        });\n        _this.initialYOffset = currentYOffset;\n      }\n\n      if (_this.isDraggedItemOutOfBounds() && _this.props.removableByMove) {\n        _this.afterIndex = _this.topOffsets.length + 1;\n      } else {\n        _this.afterIndex = binarySearch(_this.topOffsets, itemVerticalCenter);\n      }\n\n      _this.animateItems(_this.afterIndex === -1 ? 0 : _this.afterIndex, _this.state.itemDragged, offset);\n    };\n\n    _this.autoScrolling = function (clientY) {\n      var _this$listRef$current = _this.listRef.current.getBoundingClientRect(),\n          top = _this$listRef$current.top,\n          bottom = _this$listRef$current.bottom,\n          height = _this$listRef$current.height;\n\n      var viewportHeight = window.innerHeight || document.documentElement.clientHeight; // autoscrolling for the window (down)\n\n      if (bottom > viewportHeight && viewportHeight - clientY < AUTOSCROLL_ACTIVE_OFFSET) {\n        _this.setState({\n          scrollingSpeed: Math.round((AUTOSCROLL_ACTIVE_OFFSET - (viewportHeight - clientY)) / AUTOSCROLL_SPEED_RATIO),\n          scrollWindow: true\n        }); // autoscrolling for the window (up)\n\n      } else if (top < 0 && clientY < AUTOSCROLL_ACTIVE_OFFSET) {\n        _this.setState({\n          scrollingSpeed: Math.round((AUTOSCROLL_ACTIVE_OFFSET - clientY) / -AUTOSCROLL_SPEED_RATIO),\n          scrollWindow: true\n        });\n      } else {\n        if (_this.state.scrollWindow && _this.state.scrollingSpeed !== 0) {\n          _this.setState({\n            scrollingSpeed: 0,\n            scrollWindow: false\n          });\n        } // autoscrolling for containers with overflow\n\n\n        if (height + 20 < _this.listRef.current.scrollHeight) {\n          var scrollingSpeed = 0;\n\n          if (clientY - top < AUTOSCROLL_ACTIVE_OFFSET) {\n            scrollingSpeed = Math.round((AUTOSCROLL_ACTIVE_OFFSET - (clientY - top)) / -AUTOSCROLL_SPEED_RATIO);\n          } else if (bottom - clientY < AUTOSCROLL_ACTIVE_OFFSET) {\n            scrollingSpeed = Math.round((AUTOSCROLL_ACTIVE_OFFSET - (bottom - clientY)) / AUTOSCROLL_SPEED_RATIO);\n          }\n\n          if (_this.state.scrollingSpeed !== scrollingSpeed) {\n            _this.setState({\n              scrollingSpeed: scrollingSpeed\n            });\n          }\n        }\n      }\n    };\n\n    _this.animateItems = function (needle, movedItem, offset) {\n      var animateMovedItem = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      _this.getChildren().forEach(function (item, i) {\n        setItemTransition(item, _this.props.transitionDuration);\n\n        if (movedItem === i && animateMovedItem) {\n          if (movedItem === needle) {\n            return transformItem(item, null);\n          }\n\n          transformItem(item, movedItem < needle ? _this.itemTranslateOffsets.slice(movedItem + 1, needle + 1).reduce(function (a, b) {\n            return a + b;\n          }, 0) : _this.itemTranslateOffsets.slice(needle, movedItem).reduce(function (a, b) {\n            return a + b;\n          }, 0) * -1);\n        } else if (movedItem < needle && i > movedItem && i <= needle) {\n          transformItem(item, -offset);\n        } else if (i < movedItem && movedItem > needle && i >= needle) {\n          transformItem(item, offset);\n        } else {\n          transformItem(item, null);\n        }\n      });\n    };\n\n    _this.isDraggedItemOutOfBounds = function () {\n      var initialRect = _this.getChildren()[_this.state.itemDragged].getBoundingClientRect();\n\n      var targetRect = _this.ghostRef.current.getBoundingClientRect();\n\n      if (Math.abs(initialRect.left - targetRect.left) > targetRect.width) {\n        if (_this.state.itemDraggedOutOfBounds === -1) {\n          _this.setState({\n            itemDraggedOutOfBounds: _this.state.itemDragged\n          });\n        }\n\n        return true;\n      }\n\n      if (_this.state.itemDraggedOutOfBounds > -1) {\n        _this.setState({\n          itemDraggedOutOfBounds: -1\n        });\n      }\n\n      return false;\n    };\n\n    _this.onEnd = function (e) {\n      e.cancelable && e.preventDefault();\n      document.removeEventListener('mousemove', _this.schdOnMouseMove);\n      document.removeEventListener('touchmove', _this.schdOnTouchMove);\n      document.removeEventListener('mouseup', _this.schdOnEnd);\n      document.removeEventListener('touchup', _this.schdOnEnd);\n      document.removeEventListener('touchcancel', _this.schdOnEnd);\n\n      var removeItem = _this.props.removableByMove && _this.isDraggedItemOutOfBounds();\n\n      if (!removeItem && _this.props.transitionDuration > 0 && _this.afterIndex !== -2) {\n        // animate drop\n        schd(function () {\n          setItemTransition(_this.ghostRef.current, _this.props.transitionDuration, 'cubic-bezier(.2,1,.1,1)');\n\n          if (_this.afterIndex < 1 && _this.state.itemDragged === 0) {\n            transformItem(_this.ghostRef.current, 0, 0);\n          } else {\n            transformItem(_this.ghostRef.current, // compensate window scroll\n            -(window.pageYOffset - _this.lastYOffset) + // compensate container scroll\n            -(_this.listRef.current.scrollTop - _this.lastListYOffset) + (_this.state.itemDragged < _this.afterIndex ? _this.itemTranslateOffsets.slice(_this.state.itemDragged + 1, _this.afterIndex + 1).reduce(function (a, b) {\n              return a + b;\n            }, 0) : _this.itemTranslateOffsets.slice(_this.afterIndex < 0 ? 0 : _this.afterIndex, _this.state.itemDragged).reduce(function (a, b) {\n              return a + b;\n            }, 0) * -1), 0);\n          }\n        })();\n      }\n\n      _this.dropTimeout = window.setTimeout(_this.finishDrop, removeItem || _this.afterIndex === -2 ? 0 : _this.props.transitionDuration);\n    };\n\n    _this.finishDrop = function () {\n      var removeItem = _this.props.removableByMove && _this.isDraggedItemOutOfBounds();\n\n      if (removeItem || _this.afterIndex > -2 && _this.state.itemDragged !== _this.afterIndex) {\n        _this.props.onChange({\n          oldIndex: _this.state.itemDragged,\n          newIndex: removeItem ? -1 : Math.max(_this.afterIndex, 0),\n          targetRect: _this.ghostRef.current.getBoundingClientRect()\n        });\n      }\n\n      _this.getChildren().forEach(function (item) {\n        setItemTransition(item, 0);\n        transformItem(item, null);\n        item.style.touchAction = '';\n      });\n\n      _this.setState({\n        itemDragged: -1,\n        scrollingSpeed: 0\n      });\n\n      _this.afterIndex = -2; // sometimes the scroll gets messed up after the drop, fix:\n\n      if (_this.lastScroll > 0) {\n        _this.listRef.current.scrollTop = _this.lastScroll;\n        _this.lastScroll = 0;\n      }\n    };\n\n    _this.onKeyDown = function (e) {\n      var selectedItem = _this.state.selectedItem;\n\n      var index = _this.getTargetIndex(e);\n\n      if (checkIfInteractive(e.target, e.currentTarget)) {\n        return;\n      }\n\n      if (index === -1) return;\n\n      if (e.key === ' ') {\n        e.preventDefault();\n\n        if (selectedItem === index) {\n          if (selectedItem !== _this.needle) {\n            _this.getChildren().forEach(function (item) {\n              setItemTransition(item, 0);\n              transformItem(item, null);\n            });\n\n            _this.props.onChange({\n              oldIndex: selectedItem,\n              newIndex: _this.needle,\n              targetRect: _this.getChildren()[_this.needle].getBoundingClientRect()\n            });\n\n            _this.getChildren()[_this.needle].focus();\n          }\n\n          _this.setState({\n            selectedItem: -1,\n            liveText: _this.props.voiceover.dropped(selectedItem + 1, _this.needle + 1)\n          });\n\n          _this.needle = -1;\n        } else {\n          _this.setState({\n            selectedItem: index,\n            liveText: _this.props.voiceover.lifted(index + 1)\n          });\n\n          _this.needle = index;\n\n          _this.calculateOffsets();\n        }\n      }\n\n      if ((e.key === 'ArrowDown' || e.key === 'j') && selectedItem > -1 && _this.needle < _this.props.values.length - 1) {\n        e.preventDefault();\n        var offset = getTranslateOffset(_this.getChildren()[selectedItem]);\n        _this.needle++;\n\n        _this.animateItems(_this.needle, selectedItem, offset, true);\n\n        _this.setState({\n          liveText: _this.props.voiceover.moved(_this.needle + 1, false)\n        });\n      }\n\n      if ((e.key === 'ArrowUp' || e.key === 'k') && selectedItem > -1 && _this.needle > 0) {\n        e.preventDefault();\n\n        var _offset = getTranslateOffset(_this.getChildren()[selectedItem]);\n\n        _this.needle--;\n\n        _this.animateItems(_this.needle, selectedItem, _offset, true);\n\n        _this.setState({\n          liveText: _this.props.voiceover.moved(_this.needle + 1, true)\n        });\n      }\n\n      if (e.key === 'Escape' && selectedItem > -1) {\n        _this.getChildren().forEach(function (item) {\n          setItemTransition(item, 0);\n          transformItem(item, null);\n        });\n\n        _this.setState({\n          selectedItem: -1,\n          liveText: _this.props.voiceover.canceled(selectedItem + 1)\n        });\n\n        _this.needle = -1;\n      }\n\n      if ((e.key === 'Tab' || e.key === 'Enter') && selectedItem > -1) {\n        e.preventDefault();\n      }\n    };\n\n    _this.schdOnMouseMove = schd(_this.onMouseMove);\n    _this.schdOnTouchMove = schd(_this.onTouchMove);\n    _this.schdOnEnd = schd(_this.onEnd);\n    return _this;\n  }\n\n  _createClass(List, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.calculateOffsets();\n      document.addEventListener('touchstart', this.onMouseOrTouchStart, {\n        passive: false,\n        capture: false\n      });\n      document.addEventListener('mousedown', this.onMouseOrTouchStart);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(_prevProps, prevState) {\n      if (prevState.scrollingSpeed !== this.state.scrollingSpeed && prevState.scrollingSpeed === 0) {\n        this.doScrolling();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      document.removeEventListener('touchstart', this.onMouseOrTouchStart);\n      document.removeEventListener('mousedown', this.onMouseOrTouchStart);\n\n      if (this.dropTimeout) {\n        window.clearTimeout(this.dropTimeout);\n      }\n\n      this.schdOnMouseMove.cancel();\n      this.schdOnTouchMove.cancel();\n      this.schdOnEnd.cancel();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var baseStyle = {\n        userSelect: 'none',\n        WebkitUserSelect: 'none',\n        MozUserSelect: 'none',\n        msUserSelect: 'none',\n        boxSizing: 'border-box',\n        position: 'relative'\n      };\n\n      var ghostStyle = _objectSpread({}, baseStyle, {\n        top: this.state.targetY,\n        left: this.state.targetX,\n        width: this.state.targetWidth,\n        height: this.state.targetHeight,\n        position: 'fixed',\n        marginTop: 0\n      });\n\n      return React.createElement(React.Fragment, null, this.props.renderList({\n        children: this.props.values.map(function (value, index) {\n          var isHidden = index === _this2.state.itemDragged;\n          var isSelected = index === _this2.state.selectedItem;\n          var isDisabled = // @ts-ignore\n          _this2.props.values[index] && _this2.props.values[index].disabled;\n          var props = {\n            key: index,\n            tabIndex: isDisabled ? -1 : 0,\n            'aria-roledescription': _this2.props.voiceover.item(index + 1),\n            onKeyDown: _this2.onKeyDown,\n            style: _objectSpread({}, baseStyle, {\n              visibility: isHidden ? 'hidden' : undefined,\n              zIndex: isSelected ? 5000 : 0\n            })\n          };\n          return _this2.props.renderItem({\n            value: value,\n            props: props,\n            index: index,\n            isDragged: false,\n            isSelected: isSelected,\n            isOutOfBounds: false\n          });\n        }),\n        isDragged: this.state.itemDragged > -1,\n        props: {\n          ref: this.listRef\n        }\n      }), this.state.itemDragged > -1 && ReactDOM.createPortal(this.props.renderItem({\n        value: this.props.values[this.state.itemDragged],\n        props: {\n          ref: this.ghostRef,\n          style: ghostStyle,\n          onWheel: this.onWheel\n        },\n        index: this.state.itemDragged,\n        isDragged: true,\n        isSelected: false,\n        isOutOfBounds: this.state.itemDraggedOutOfBounds > -1\n      }), this.props.container || document.body), React.createElement(\"div\", {\n        \"aria-live\": \"assertive\",\n        role: \"log\",\n        \"aria-atomic\": \"true\",\n        style: {\n          position: 'absolute',\n          width: '1px',\n          height: '1px',\n          margin: '-1px',\n          border: '0px',\n          padding: '0px',\n          overflow: 'hidden',\n          clip: 'rect(0px, 0px, 0px, 0px)',\n          clipPath: 'inset(100%)'\n        }\n      }, this.state.liveText));\n    }\n  }]);\n\n  return List;\n}(React.Component);\n\nList.defaultProps = {\n  transitionDuration: 300,\n  lockVertically: false,\n  removableByMove: false,\n  voiceover: {\n    item: function item(position) {\n      return \"You are currently at a draggable item at position \".concat(position, \". Press space bar to lift.\");\n    },\n    lifted: function lifted(position) {\n      return \"You have lifted item at position \".concat(position, \". Press j to move down, k to move up, space bar to drop and escape to cancel.\");\n    },\n    moved: function moved(position, up) {\n      return \"You have moved the lifted item \".concat(up ? 'up' : 'down', \" to position \").concat(position, \". Press j to move down, k to move up, space bar to drop and escape to cancel.\");\n    },\n    dropped: function dropped(from, to) {\n      return \"You have dropped the item. It has moved from position \".concat(from, \" to \").concat(to, \".\");\n    },\n    canceled: function canceled(position) {\n      return \"You have cancelled the movement. The item has returned to its starting position of \".concat(position, \".\");\n    }\n  }\n};\nexport default List;","map":null,"metadata":{},"sourceType":"module"}